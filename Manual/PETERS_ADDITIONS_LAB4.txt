Chapter 2: Game Console and Engine  
 Section 2.1: Game Console  
  Subsection 2.1.a: Xilinx University Program Board.  
    
  Subsection 2.1.b: Xilinx Virtex II. Pro EDK System    
 Section 2.2: Game Engine   
  Subsection 2.2.a: Software Game Engine  
Timing System
Our application is built upon a framework of timers.
The following timed events exist:
New Space Ship:  If the space ship is not currently on the screen, this timed event has a random probability of initializing the space ship on the screen.
Move Aliens:  Moves all the aliens one move.  If the aliens have reached the bottom of the screen, initiate game over state.
Move Space Ship:  If the space ship is currently on the screen, move the space ship one step across the screen.
Fire Alien Bullet:  If less than four bullets are currently on the screen, this timed event has a random probability of initializing a new bullet on the screen.  It chooses a random non-empty column among the aliens and the bullet is fired from the lowest alien in that column.
Poll Buttons:  Check the value of the push buttons.  If the left button is pushed, move the tank left.  If the tank is already on the left edge of the screen, do nothing.  If the right button is pushed, move the tank right.  If the tank is already on the right edge of the screen, do nothing.  If the middle button is pushed, fire a new bullet from the tank.  If there is already a bullet on the screen, do nothing.
Move Bullets:  Move all bullet along the screen.  Alien bullets move down the screen.  Tank bullets move up the screen.  For each bullet currently on screen, detect any possible collisions.  See the section further down on "Detecting Collisions" for details.
Update Bullets:  The alien bullets animate as they move.  Update bullets updates the stage of the animation that should be draw to the screen.
Process Explosions:  There are three types of explosions.  Each explosion has different behavior.  This timed event updates the explosion, resulting in either an additional step in the animation being displayed or the explosion no longer being drawn to the screen.
Render Screen:  Renders the screen.  See the section titled "Rendering".

A PIT handler is installed to update a global pit_counter variable.  In main(), there is a timer loop that does the following:
  1)  Take a snapshot of pit_counter.  
  2)  Compare this value with the previous snapshot.
  3)  Iterate through each Timer and increment the Timer's counter.
  4)  If the Timer's counter exceeds the maximum value, reset the counter and execute the registered callback function.

The timer loop will continue to run until the game over state is reached.

Detecting Collisions

The following diagram demonstrates the general logic used to determine a collision.

Render

We render passively.  That is to say, we render the screen on a set interval whether or not anything has changed.

Double Buffering

In order to avoid flickering on the screen, we implement double buffering.  We never modify the frame currently being displayed.  All modifications are made to an inactive frame.  The diagram shows the steps in rendering the screen.

Flying over the bunkers

When the aliens reach the bunkers, they need to march over them.  In order to redraw the bunkers properly, we keep the state of the bunkers in FRAME3.  When erasing a value in the bunkers region, the screen is erased to the value of that pixel as stored in FRAME3.

  Subsection 2.2.b: Software APIs 

Rendering of images

Images are stored in memory as an encoded bitstring.  A Xuint16 can represent a single line of an image up to 16 pixels wide.  Each image is an array of these encoded bitstrings.  To draw to the screen, the images are scaled up to double their size.  A single pixel in the stored image corresponds to a 2 by 2 block of pixels on the screen.

Each image type has it's own rendering function.  The functions typically take an x and y coordinate, a frame to draw to, and a color to draw.


  Subsection 2.3.c: Meeting the Game Specifications
 Bug Reports:
